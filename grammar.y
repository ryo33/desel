%{

//TODO Put your favorite license here
		
// yacc source generated by ebnf2y[1]
// at 2016-04-01 15:39:52.026333071 +0900 JST
//
//  $ ebnf2y -o grammar.y -pkg=desel -start=Statements lang/grammar.ebnf
//
// CAUTION: If this file is a Go source file (*.go), it was generated
// automatically by '$ go tool yacc' from a *.y file - DO NOT EDIT in that case!
// 
//   [1]: http://github.com/cznic/ebnf2y

package desel //TODO real package name

//TODO required only be the demo _dump function
import (
	"bytes"
	"fmt"
	"strings"

	"github.com/cznic/strutil"
)

%}

%union {
	item interface{} //TODO insert real field(s)
}

%token	AND
%token	LABEL_CHARACTERS
%token	MINUS
%token	NEWLINE
%token	NOT
%token	PREFIX_OF_COMMENT
%token	PREFIX_OF_ELEMENT
%token	PREFIX_OF_INLINE_COMMENT
%token	PREFIX_OF_SET
%token	UTF_CHARACTERS
%token	W

%type	<item> 	/*TODO real type(s), if/where applicable */
	AND
	LABEL_CHARACTERS
	MINUS
	NEWLINE
	NOT
	PREFIX_OF_COMMENT
	PREFIX_OF_ELEMENT
	PREFIX_OF_INLINE_COMMENT
	PREFIX_OF_SET
	UTF_CHARACTERS
	W

%type	<item> 	/*TODO real type(s), if/where applicable */
	AdditionalElementDefinition
	AdditionalElementDefinition1
	AdditionalSetDefinition
	AdditionalSetDefinition1
	Comment
	Element
	Element1
	ElementDefinition
	ElementDefinition1
	ElementDefinition2
	ElementDefinition3
	ElementDefinition31
	ElementDefinitionItem
	ElementWithOptNot
	ElementWithPrefix
	ElementWithPrefixAndOptNot
	ElementsDefinition
	ElementsDefinition1
	ElementsDefinitionItem
	ElementsDefinitionItem1
	ElementsDefinitionItem2
	Expression
	Expression1
	Expression11
	ExpressionAnd
	ExpressionAnd1
	ExpressionMin
	HomonymousElement
	HomonymousSet
	InlineComment
	Label
	LabelWithOptNot
	NotWs
	NotWws
	OptNotWs
	OptNotWs1
	OptNotWws
	OptNotWws1
	Set
	Set1
	SetDefinition
	SetDefinition1
	SetDefinition2
	SetDefinition3
	SetDefinition31
	SetDefinitionItem
	SetWithOptNot
	SetWithPrefix
	SetWithPrefixAndOptNot
	SetsDefinition
	SetsDefinition1
	SetsDefinitionItem
	SetsDefinitionItem1
	SetsDefinitionItem2
	SetsDefinitionItem21
	Start
	Statement
	Statements
	Statements1
	WrappedExpression
	WrappedLabel
	Ws
	Ws1
	WsNewline
	Wws

/*TODO %left, %right, ... declarations */

%start Start

%%

AdditionalElementDefinition:
	PREFIX_OF_ELEMENT AdditionalElementDefinition1
	{
		$$ = []AdditionalElementDefinition{$1, $2} //TODO 1
	}

AdditionalElementDefinition1:
	/* EMPTY */
	{
		$$ = []AdditionalElementDefinition1(nil) //TODO 2
	}
|	AdditionalElementDefinition1 Wws ElementDefinitionItem
	{
		$$ = append($1.([]AdditionalElementDefinition1), $2, $3) //TODO 3
	}

AdditionalSetDefinition:
	PREFIX_OF_SET AdditionalSetDefinition1
	{
		$$ = []AdditionalSetDefinition{$1, $2} //TODO 4
	}

AdditionalSetDefinition1:
	/* EMPTY */
	{
		$$ = []AdditionalSetDefinition1(nil) //TODO 5
	}
|	AdditionalSetDefinition1 Wws SetDefinitionItem
	{
		$$ = append($1.([]AdditionalSetDefinition1), $2, $3) //TODO 6
	}

Comment:
	PREFIX_OF_COMMENT UTF_CHARACTERS NEWLINE
	{
		$$ = []Comment{$1, $2, $3} //TODO 7
	}

Element:
	Element1 Label
	{
		$$ = []Element{$1, $2} //TODO 8
	}

Element1:
	/* EMPTY */
	{
		$$ = nil //TODO 9
	}
|	PREFIX_OF_ELEMENT
	{
		$$ = $1 //TODO 10
	}

ElementDefinition:
	ElementWithPrefix ElementDefinition1 ElementDefinition2 InlineComment WsNewline ElementDefinition3
	{
		$$ = []ElementDefinition{$1, $2, $3, $4, $5, $6} //TODO 11
	}

ElementDefinition1:
	/* EMPTY */
	{
		$$ = nil //TODO 12
	}
|	HomonymousSet
	{
		$$ = $1 //TODO 13
	}

ElementDefinition2:
	/* EMPTY */
	{
		$$ = []ElementDefinition2(nil) //TODO 14
	}
|	ElementDefinition2 Wws ElementDefinitionItem
	{
		$$ = append($1.([]ElementDefinition2), $2, $3) //TODO 15
	}

ElementDefinition3:
	/* EMPTY */
	{
		$$ = []ElementDefinition3(nil) //TODO 16
	}
|	ElementDefinition3 ElementDefinition31
	{
		$$ = append($1.([]ElementDefinition3), $2) //TODO 17
	}

ElementDefinition31:
	Comment
	{
		$$ = $1 //TODO 18
	}
|	AdditionalElementDefinition InlineComment WsNewline
	{
		$$ = []ElementDefinition31{$1, $2, $3} //TODO 19
	}

ElementDefinitionItem:
	SetWithOptNot
	{
		$$ = $1 //TODO 20
	}

ElementWithOptNot:
	ElementWithPrefixAndOptNot
	{
		$$ = $1 //TODO 21
	}
|	LabelWithOptNot
	{
		$$ = $1 //TODO 22
	}

ElementWithPrefix:
	PREFIX_OF_ELEMENT Label
	{
		$$ = []ElementWithPrefix{$1, $2} //TODO 23
	}

ElementWithPrefixAndOptNot:
	OptNotWs ElementWithPrefix
	{
		$$ = []ElementWithPrefixAndOptNot{$1, $2} //TODO 24
	}

ElementsDefinition:
	PREFIX_OF_ELEMENT PREFIX_OF_ELEMENT ElementsDefinition1 InlineComment WsNewline
	{
		$$ = []ElementsDefinition{$1, $2, $3, $4, $5} //TODO 25
	}

ElementsDefinition1:
	/* EMPTY */
	{
		$$ = []ElementsDefinition1(nil) //TODO 26
	}
|	ElementsDefinition1 Wws ElementsDefinitionItem
	{
		$$ = append($1.([]ElementsDefinition1), $2, $3) //TODO 27
	}

ElementsDefinitionItem:
	Element ElementsDefinitionItem1 ElementsDefinitionItem2
	{
		$$ = []ElementsDefinitionItem{$1, $2, $3} //TODO 28
	}

ElementsDefinitionItem1:
	/* EMPTY */
	{
		$$ = nil //TODO 29
	}
|	HomonymousSet
	{
		$$ = $1 //TODO 30
	}

ElementsDefinitionItem2:
	/* EMPTY */
	{
		$$ = []ElementsDefinitionItem2(nil) //TODO 31
	}
|	ElementsDefinitionItem2 Wws SetWithPrefixAndOptNot
	{
		$$ = append($1.([]ElementsDefinitionItem2), $2, $3) //TODO 32
	}

Expression:
	OptNotWs WrappedExpression
	{
		$$ = []Expression{$1, $2} //TODO 33
	}
|	ExpressionAnd Expression1
	{
		$$ = []Expression{$1, $2} //TODO 34
	}

Expression1:
	/* EMPTY */
	{
		$$ = []Expression1(nil) //TODO 35
	}
|	Expression1 Expression11 ExpressionAnd
	{
		$$ = append($1.([]Expression1), $2, $3) //TODO 36
	}

Expression11:
	Ws MINUS Ws
	{
		$$ = []Expression11{$1, $2, $3} //TODO 37
	}
|	Wws
	{
		$$ = $1 //TODO 38
	}

ExpressionAnd:
	ExpressionMin ExpressionAnd1
	{
		$$ = []ExpressionAnd{$1, $2} //TODO 39
	}

ExpressionAnd1:
	/* EMPTY */
	{
		$$ = []ExpressionAnd1(nil) //TODO 40
	}
|	ExpressionAnd1 Ws AND Ws ExpressionMin
	{
		$$ = append($1.([]ExpressionAnd1), $2, $3, $4, $5) //TODO 41
	}

ExpressionMin:
	SetWithPrefixAndOptNot
	{
		$$ = $1 //TODO 42
	}

HomonymousElement:
	Ws PREFIX_OF_ELEMENT
	{
		$$ = []HomonymousElement{$1, $2} //TODO 43
	}

HomonymousSet:
	Ws PREFIX_OF_SET
	{
		$$ = []HomonymousSet{$1, $2} //TODO 44
	}

InlineComment:
	Ws PREFIX_OF_INLINE_COMMENT UTF_CHARACTERS
	{
		$$ = []InlineComment{$1, $2, $3} //TODO 45
	}

Label:
	LABEL_CHARACTERS
	{
		$$ = $1 //TODO 46
	}
|	WrappedLabel
	{
		$$ = $1 //TODO 47
	}

LabelWithOptNot:
	OptNotWs WrappedLabel
	{
		$$ = []LabelWithOptNot{$1, $2} //TODO 48
	}
|	OptNotWws Label
	{
		$$ = []LabelWithOptNot{$1, $2} //TODO 49
	}

NotWs:
	NOT Ws
	{
		$$ = []NotWs{$1, $2} //TODO 50
	}

NotWws:
	NOT Wws
	{
		$$ = []NotWws{$1, $2} //TODO 51
	}

OptNotWs:
	OptNotWs1
	{
		$$ = $1 //TODO 52
	}

OptNotWs1:
	/* EMPTY */
	{
		$$ = nil //TODO 53
	}
|	NotWs
	{
		$$ = $1 //TODO 54
	}

OptNotWws:
	OptNotWws1
	{
		$$ = $1 //TODO 55
	}

OptNotWws1:
	/* EMPTY */
	{
		$$ = nil //TODO 56
	}
|	NotWws
	{
		$$ = $1 //TODO 57
	}

Set:
	Set1 Label
	{
		$$ = []Set{$1, $2} //TODO 58
	}

Set1:
	/* EMPTY */
	{
		$$ = nil //TODO 59
	}
|	PREFIX_OF_SET
	{
		$$ = $1 //TODO 60
	}

SetDefinition:
	SetWithPrefix SetDefinition1 SetDefinition2 InlineComment WsNewline SetDefinition3
	{
		$$ = []SetDefinition{$1, $2, $3, $4, $5, $6} //TODO 61
	}

SetDefinition1:
	/* EMPTY */
	{
		$$ = nil //TODO 62
	}
|	HomonymousElement
	{
		$$ = $1 //TODO 63
	}

SetDefinition2:
	/* EMPTY */
	{
		$$ = []SetDefinition2(nil) //TODO 64
	}
|	SetDefinition2 Wws SetDefinitionItem
	{
		$$ = append($1.([]SetDefinition2), $2, $3) //TODO 65
	}

SetDefinition3:
	/* EMPTY */
	{
		$$ = []SetDefinition3(nil) //TODO 66
	}
|	SetDefinition3 SetDefinition31
	{
		$$ = append($1.([]SetDefinition3), $2) //TODO 67
	}

SetDefinition31:
	Comment
	{
		$$ = $1 //TODO 68
	}
|	AdditionalSetDefinition InlineComment WsNewline
	{
		$$ = []SetDefinition31{$1, $2, $3} //TODO 69
	}

SetDefinitionItem:
	ElementWithOptNot HomonymousSet
	{
		$$ = []SetDefinitionItem{$1, $2} //TODO 70
	}
|	Expression
	{
		$$ = $1 //TODO 71
	}

SetWithOptNot:
	SetWithPrefixAndOptNot
	{
		$$ = $1 //TODO 72
	}
|	LabelWithOptNot
	{
		$$ = $1 //TODO 73
	}

SetWithPrefix:
	PREFIX_OF_SET Label
	{
		$$ = []SetWithPrefix{$1, $2} //TODO 74
	}

SetWithPrefixAndOptNot:
	OptNotWs ElementWithPrefix
	{
		$$ = []SetWithPrefixAndOptNot{$1, $2} //TODO 75
	}

SetsDefinition:
	PREFIX_OF_SET PREFIX_OF_SET SetsDefinition1 InlineComment WsNewline
	{
		$$ = []SetsDefinition{$1, $2, $3, $4, $5} //TODO 76
	}

SetsDefinition1:
	/* EMPTY */
	{
		$$ = []SetsDefinition1(nil) //TODO 77
	}
|	SetsDefinition1 Wws SetsDefinitionItem
	{
		$$ = append($1.([]SetsDefinition1), $2, $3) //TODO 78
	}

SetsDefinitionItem:
	Set SetsDefinitionItem1 SetsDefinitionItem2
	{
		$$ = []SetsDefinitionItem{$1, $2, $3} //TODO 79
	}

SetsDefinitionItem1:
	/* EMPTY */
	{
		$$ = nil //TODO 80
	}
|	HomonymousElement
	{
		$$ = $1 //TODO 81
	}

SetsDefinitionItem2:
	/* EMPTY */
	{
		$$ = []SetsDefinitionItem2(nil) //TODO 82
	}
|	SetsDefinitionItem2 Wws SetsDefinitionItem21
	{
		$$ = append($1.([]SetsDefinitionItem2), $2, $3) //TODO 83
	}

SetsDefinitionItem21:
	ElementWithPrefixAndOptNot
	{
		$$ = $1 //TODO 84
	}
|	WrappedExpression
	{
		$$ = $1 //TODO 85
	}

Start:
	Statements
	{
		_parserResult = $1 //TODO 86
	}

Statement:
	SetDefinition
	{
		$$ = $1 //TODO 87
	}
|	ElementDefinition
	{
		$$ = $1 //TODO 88
	}
|	SetsDefinition
	{
		$$ = $1 //TODO 89
	}
|	ElementsDefinition
	{
		$$ = $1 //TODO 90
	}
|	Comment
	{
		$$ = $1 //TODO 91
	}

Statements:
	Statements1
	{
		$$ = $1 //TODO 92
	}

Statements1:
	/* EMPTY */
	{
		$$ = []Statements1(nil) //TODO 93
	}
|	Statements1 Statement
	{
		$$ = append($1.([]Statements1), $2) //TODO 94
	}

WrappedExpression:
	'(' Ws Expression Ws ')'
	{
		$$ = []WrappedExpression{"(", $2, $3, $4, ")"} //TODO 95
	}

WrappedLabel:
	'"' UTF_CHARACTERS '"'
	{
		$$ = []WrappedLabel{"\"", $2, "\""} //TODO 96
	}
|	'\'' UTF_CHARACTERS '\''
	{
		$$ = []WrappedLabel{"'", $2, "'"} //TODO 97
	}

Ws:
	Ws1
	{
		$$ = $1 //TODO 98
	}

Ws1:
	/* EMPTY */
	{
		$$ = []Ws1(nil) //TODO 99
	}
|	Ws1 W
	{
		$$ = append($1.([]Ws1), $2) //TODO 100
	}

WsNewline:
	Ws NEWLINE
	{
		$$ = []WsNewline{$1, $2} //TODO 101
	}

Wws:
	W Ws
	{
		$$ = []Wws{$1, $2} //TODO 102
	}

%%

//TODO remove demo stuff below

var _parserResult interface{}

type (
	AdditionalElementDefinition interface{}
	AdditionalElementDefinition1 interface{}
	AdditionalSetDefinition interface{}
	AdditionalSetDefinition1 interface{}
	Comment interface{}
	Element interface{}
	Element1 interface{}
	ElementDefinition interface{}
	ElementDefinition1 interface{}
	ElementDefinition2 interface{}
	ElementDefinition3 interface{}
	ElementDefinition31 interface{}
	ElementDefinitionItem interface{}
	ElementWithOptNot interface{}
	ElementWithPrefix interface{}
	ElementWithPrefixAndOptNot interface{}
	ElementsDefinition interface{}
	ElementsDefinition1 interface{}
	ElementsDefinitionItem interface{}
	ElementsDefinitionItem1 interface{}
	ElementsDefinitionItem2 interface{}
	Expression interface{}
	Expression1 interface{}
	Expression11 interface{}
	ExpressionAnd interface{}
	ExpressionAnd1 interface{}
	ExpressionMin interface{}
	HomonymousElement interface{}
	HomonymousSet interface{}
	InlineComment interface{}
	Label interface{}
	LabelWithOptNot interface{}
	NotWs interface{}
	NotWws interface{}
	OptNotWs interface{}
	OptNotWs1 interface{}
	OptNotWws interface{}
	OptNotWws1 interface{}
	Set interface{}
	Set1 interface{}
	SetDefinition interface{}
	SetDefinition1 interface{}
	SetDefinition2 interface{}
	SetDefinition3 interface{}
	SetDefinition31 interface{}
	SetDefinitionItem interface{}
	SetWithOptNot interface{}
	SetWithPrefix interface{}
	SetWithPrefixAndOptNot interface{}
	SetsDefinition interface{}
	SetsDefinition1 interface{}
	SetsDefinitionItem interface{}
	SetsDefinitionItem1 interface{}
	SetsDefinitionItem2 interface{}
	SetsDefinitionItem21 interface{}
	Start interface{}
	Statement interface{}
	Statements interface{}
	Statements1 interface{}
	WrappedExpression interface{}
	WrappedLabel interface{}
	Ws interface{}
	Ws1 interface{}
	WsNewline interface{}
	Wws interface{}
)
	
func _dump() {
	s := fmt.Sprintf("%#v", _parserResult)
	s = strings.Replace(s, "%", "%%", -1)
	s = strings.Replace(s, "{", "{%i\n", -1)
	s = strings.Replace(s, "}", "%u\n}", -1)
	s = strings.Replace(s, ", ", ",\n", -1)
	var buf bytes.Buffer
	strutil.IndentFormatter(&buf, ". ").Format(s)
	buf.WriteString("\n")
	a := strings.Split(buf.String(), "\n")
	for _, v := range a {
		if strings.HasSuffix(v, "(nil)") || strings.HasSuffix(v, "(nil),") {
			continue
		}
	
		fmt.Println(v)
	}
}

// End of demo stuff
